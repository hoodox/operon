package com.hoodox.operon.maven.plugin.pnml;

/*
 * Copyright 2001-2005 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import static com.hoodox.operon.helper.jaxb.woped.WopedConst.FILENAME_DefaultOperonToolSpecifics;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.codehaus.plexus.util.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.hoodox.commons.configurable.ConfigurationHelper;
import com.hoodox.commons.exceptions.BaseSystemException;
import com.hoodox.operon.helper.jaxb.OpnmlJAXBHelper;
import com.hoodox.operon.helper.jaxb.woped.WopedJAXBHelper;
import com.hoodox.operon.jaxb.opnml.NetType;
import com.hoodox.operon.jaxb.opnml.PnmlType;

/**
 * This plugin takes a source and target files in Woped format and tries to
 * merge them to a Woped and Operon combined format. This just adds Operon
 * toolspecifics to the Woped pnml.
 * 
 * @goal generate
 * @phase generate-sources
 * 
 * @description Maven-plugin to merge Operon and Woped PNML files at
 *              'generate-sources' phase.
 * @author Chung Hua (chung.hua@hoodox.com)
 */
public class OperonWopedMergeMojo extends AbstractMojo {

	private final Logger log = LoggerFactory.getLogger(this.getClass()
			.getName());

	/**
	 * Location of the file.
	 * 
	 * @parameter expression="${project.build.outputDirectory}"
	 * @required
	 */
	private String outputFilename;

	/**
	 * Location of the source file.
	 * 
	 * @parameter
	 * @required
	 */
	private File sourceFile;

	/**
	 * Location of the target file.
	 * 
	 * @parameter
	 * @required
	 */
	private File targetFile;

    /**
     * The optional directory where generated resources can be placed, generated by addons/plugins.
     * 
     * @parameter
     */
    private File generatedResourcesDirectory;
	
	/**
	 * Clears the output directory on each run. Defaults to 'true' but if false,
	 * will not clear the directory.
	 * 
	 * @parameter default-value="true"
	 */
	private boolean clearOutputDir;

	public void execute() throws MojoExecutionException {

		String sourceFileName = this.sourceFile.getAbsolutePath();
		String targetFileName = this.targetFile.getAbsolutePath();

		JAXBElement<PnmlType> sourceJAXBElement = _loadFirstJaxbElementByFileName(sourceFileName);
		JAXBElement<PnmlType> targetJAXBElement = _loadFirstJaxbElementByFileName(targetFileName);
		JAXBElement<PnmlType> defaultJAXBElement = _loadFirstJaxbElementByFileName(FILENAME_DefaultOperonToolSpecifics);

        getLog().info( "Generating source..." );

        prepareDirectory( this.generatedResourcesDirectory );

        if ( this.generatedResourcesDirectory != null )
        {
            prepareDirectory( this.generatedResourcesDirectory );
        }
		
		NetType sourceNet = _loadFirstNetInJaxbElement(sourceJAXBElement);
		NetType targetNet = _loadFirstNetInJaxbElement(targetJAXBElement);
		NetType defaultNet = _loadFirstNetInJaxbElement(defaultJAXBElement);

		WopedJAXBHelper.mergeOperonToolSpecificToNet(sourceNet, targetNet,
				defaultNet);

		final String contextPackage = "com.hoodox.operon.jaxb.opnml";

		try {
			JAXBContext jc = JAXBContext.newInstance(contextPackage);
			Marshaller m = jc.createMarshaller();
			m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

			FileOutputStream out = null;

			try {
				String fullOutputFilename = this.generatedResourcesDirectory.getAbsolutePath() 
											+  File.separator
											+ this.outputFilename;
				out = new FileOutputStream(fullOutputFilename);

			} catch (IOException e) {
				throw new MojoExecutionException(e.getMessage(), e);
			}

			m.marshal(targetJAXBElement, out);

		} catch (JAXBException e) {
			throw new MojoExecutionException(e.getMessage(), e);

		}

	}

	private JAXBElement<PnmlType> _loadFirstJaxbElementByFileName(
			String filename) {
		String xmlStr = loadXmlStr(filename);

		return OpnmlJAXBHelper.loadNetFromXmlStrReturnPnml(xmlStr, this.log);

	}

	private static String loadXmlStr(String filename) {
		// default will use class path
		// to load up file
		ConfigurationHelper configHelper = new ConfigurationHelper();
		try {
			configHelper.createDomFromFile(filename);
			return configHelper.getDomAsString();

		} catch (Exception e) {
			throw new BaseSystemException(e);
		}

	}

	private NetType _loadFirstNetInJaxbElement(JAXBElement<PnmlType> jaxbElement) {
		PnmlType pnmlElement = jaxbElement.getValue();
		List<NetType> netList = pnmlElement.getNet();
		NetType[] nets = netList.toArray(new NetType[netList.size()]);

		return nets[0];

	}

	private void prepareDirectory(File dir) throws MojoExecutionException {
		// If the directory exists, whack it to start fresh
		if (clearOutputDir && dir.exists()) {
			try {
				FileUtils.deleteDirectory(dir);
			} catch (IOException e) {
				throw new MojoExecutionException("Error cleaning directory "
						+ dir.getAbsolutePath(), e);
			}
		}

		if (!dir.exists()) {
			if (!dir.mkdirs()) {
				throw new MojoExecutionException("Could not create directory "
						+ dir.getAbsolutePath());
			}
		}
	}

}
